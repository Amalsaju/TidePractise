import { ed25519 } from '@noble/curves/ed25519';
import { concatBytes } from '@noble/hashes/utils';
import { hex, base32, utils } from '@scure/base';
const base36 = utils.chain(utils.radix(36), utils.alphabet('0123456789abcdefghijklmnopqrstuvwxyz'), utils.padding(0), utils.join(''));
export function formatPublicKey(pubBytes) {
    return `ipns://k${base36.encode(pubBytes)}`;
}
export function parseAddress(address) {
    address = address.toLowerCase();
    if (address.startsWith('ipns://'))
        address = address.slice(7);
    let hexKey;
    if (address.startsWith('k')) {
        hexKey = hex.encode(base36.decode(address.slice(1)));
    }
    else if (address.startsWith('b')) {
        hexKey = hex.encode(base32.decode(address.slice(1).toUpperCase()));
    }
    else if (address.startsWith('f')) {
        hexKey = address.slice(1);
    }
    else
        throw new Error('Unsupported Base-X Format');
    if (hexKey.startsWith('0172002408011220') && hexKey.length === 80) {
        return hex.decode(hexKey);
    }
    throw new Error('Invalid IPNS Key Prefix: ' + hexKey);
}
export async function getKeys(seed) {
    if (seed.length != 32)
        throw new TypeError('Seed must be 32 bytes in length');
    const pubKey = await ed25519.getPublicKey(seed);
    const pubKeyBytes = concatBytes(new Uint8Array([0x01, 0x72, 0x00, 0x24, 0x08, 0x01, 0x12, 0x20]), pubKey);
    const hexKey = hex.encode(pubKeyBytes).toLowerCase();
    return {
        publicKey: `0x${hexKey}`,
        privateKey: `0x${hex.encode(concatBytes(new Uint8Array([0x08, 0x01, 0x12, 0x40]), seed, pubKey))}`,
        base36: `ipns://k${base36.encode(pubKeyBytes)}`,
        base32: `ipns://b${base32.encode(pubKeyBytes).toLowerCase()}`,
        base16: `ipns://f${hexKey}`,
        contenthash: `0xe501${hexKey}`,
    };
}
export default getKeys;
